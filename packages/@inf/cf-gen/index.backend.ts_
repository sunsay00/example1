import RDSStore from './api/stores/rdsstore';
import CacheStore from './api/stores/cachestore';
import { createServiceMapper, MappedServices } from './api/mapper';
import { QueryParam, QueryResult } from '@inf/cf-gen';
import { Resolver } from './resolver';

import { IStore } from './types/storeinterfaces';
import { IUserContext } from '.';
import * as M from './types/serviceinterfaces';
import Mapper from './api/mapper';

export { IStore } from './types/storeinterfaces';
export * from './types/serviceinterfaces';

export type IUserContext = {
  sub: string,
  groups?: string[],
};

export type INotificationManager<C extends IUserContext> = {
  dispatchDeckFactories(store: IStore<C>, sub: string, action: string, obj: M.DeckFactory): Promise<void>,
  dispatchDecks(store: IStore<C>, sub: string, action: string, obj: M.Deck): Promise<void>,
  dispatchCommentLists(store: IStore<C>, sub: string, action: string, obj: M.CommentList): Promise<void>,
  dispatchDealerships(store: IStore<C>, sub: string, action: string, obj: M.Dealership): Promise<void>,
  dispatchCarInventories(store: IStore<C>, sub: string, action: string, obj: M.CarInventory): Promise<void>,
  dispatchSellers(store: IStore<C>, sub: string, action: string, obj: M.Seller): Promise<void>,
  dispatchNotes(store: IStore<C>, sub: string, action: string, obj: M.Note): Promise<void>,
  dispatchCarInfos(store: IStore<C>, sub: string, action: string, obj: M.CarInfo): Promise<void>,
};

export type ITestingService<C extends IUserContext> = {
  adminAuthorized(user: IUserContext, fields: string[], mapper: Mapper<C>, arg: string): Promise<string>;
  authorized(user: IUserContext, fields: string[], mapper: Mapper<C>, arg: string): Promise<string>;
  unauthorized(user: IUserContext, fields: string[], mapper: Mapper<C>, arg: string): Promise<string>;
};

export const createCachedResolver = <C extends IUserContext>(
  stage: string,
  notifications: INotificationManager<C>,
  cache: ICacheClient,
  db: IDBClient,
  services: MappedServices<C>,
  onPreResolve?: () => Promise<void>,
  onPostResolve?: () => Promise<void>,
) => {
  const store = new RDSStore(stage, db);
  return new Resolver(
    stage,
    store,
    createServiceMapper(notifications, new CacheStore(store, cache), services),
    onPreResolve,
    onPostResolve);
};

export const createResolver = <C extends IUserContext>(params: {
  stage: string,
  notifications: INotificationManager<C>,
  db: IDBClient,
  services: MappedServices<C>,
  onPreResolve?: () => Promise<void>,
  onPostResolve?: () => Promise<void>,
}) => {
  const store = new RDSStore(params.stage, params.db);
  return new Resolver(
    params.stage,
    store,
    createServiceMapper(params.notifications, store, params.services),
    params.onPreResolve,
    params.onPostResolve);
}

export type IDBClient = {
  query(query: string, params: QueryParam[]): Promise<QueryResult>;
  beginTransaction(): Promise<QueryResult>,
  rollbackTransaction(): Promise<QueryResult>,
  commitTransaction(): Promise<QueryResult>,
  prepareString(value: unknown): string,
}

export type IMultiCacheClient = {
  set(key: string, value: string): void;
  get(key: string): void;
  del(keys: string[]): void;
  exists(key: string): void;
  hget(key: string, field: string): void;
  hmget(key: string, fields: string[]): void;
  hset(key: string, field: string, value: string): void;
  hmset(key: string, values: [string, string][]): void;
  expire(key: string, seconds: number): void;
  hdel(key: string, fields: string[]): void;
  zadd(key: string, values: [string, string][]): void;
  zremrangebyscore(key: string, minScore: string, inclusiveMaxScore: string): void;
  zrangebyscore(key: string, inclusiveMinScore: string, inclusiveMaxScore: string, options?: { offset: number, count: number }): void;
  zrevrangebyscore(key: string, inclusiveMinScore: string, inclusiveMaxScore: string, options?: { offset: number, count: number }): void;
  zrem(key: string, members: string[]): void;
  geoadd(key: string, values: { lon: number, lat: number, value: string }[]): void;
  georadius(key: string, lon: number, lat: number, radius: number, unit: 'm' | 'km' | 'ft' | 'mi', options?: { count: number }): void;
  exec(): Promise<string[]>;
};

export type ICacheClient = {
  set(key: string, value: string): Promise<void>;
  get(key: string): Promise<string | undefined>;
  del(keys: string[]): Promise<void>;
  exists(key: string): Promise<boolean>;
  hget(key: string, field: string): Promise<string | undefined>;
  hmget(key: string, fields: string[]): Promise<(string | undefined)[]>;
  hset(key: string, field: string, value: string): Promise<void>;
  hmset(key: string, values: [string, string][]): Promise<void>;
  hdel(key: string, fields: string[]): Promise<void>;
  zadd(key: string, values: [string, string][]): Promise<void>;
  zremrangebyscore(key: string, minScore: string, inclusiveMaxScore: string): Promise<void>;
  zrangebyscore(key: string, inclusiveMinScore: string, inclusiveMaxScore: string, options?: { offset: number, count: number }): Promise<string[]>;
  zrevrangebyscore(key: string, inclusiveMinScore: string, inclusiveMaxScore: string, options?: { offset: number, count: number }): Promise<string[]>;
  zrem(key: string, members: string[]): Promise<void>;
  geoadd(key: string, values: { lon: number, lat: number, value: string }[]): Promise<void>;
  georadius(key: string, lon: number, lat: number, radius: number, unit: 'm' | 'km' | 'ft' | 'mi', options?: { count: number }): Promise<(string | [string, string | [string, string]])[]>;
  multi(): IMultiCacheClient;
};