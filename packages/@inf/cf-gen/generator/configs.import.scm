(module configs (configs-generate)
  (import scheme chicken data-structures tools)
  (require-extension srfi-13 srfi-1)

	(define (config-emit name)
		(list
      "// this file has been automatically generated, do not modify\n"
      "\nconst DOMAIN = 'pygine.com';"
      "\n"
      "\ntype Obj<T> = { [key: string]: T | undefined };"
      "\n"
      "\nlet _config: Obj<string> = {};"
      "\n"
      "\nlet _handlers: (() => Promise<void>)[]|undefined = [];"
      (if (eq? name 'mobileapp)
        "\nlet _loaded = true;"
        "\nlet _loaded = false;")
      "\nlet _name = '[NAME NOT SET]';"
      "\nlet _stage = '[STAGE NOT SET]';"
      "\n"
      "\nexport const keys = () => Object.keys(_config);"
      "\n"
      "\nexport default (envvar: string): string => {"
      "\n  if (!_loaded) {"
      "\n    throw new Error(`attempted to access property ${envvar} before config has been loaded ${_name}`);"
      "\n  } else if (_config[envvar] == undefined) {"
      "\n    throw new Error(`config error: property '${envvar}' is undefined (name=${_name} stage=${_stage} node_env=${process.env['NODE_ENV']})`);"
      "\n  }"
      "\n  return _config[envvar]!;"
      "\n}"
      (if (or (eq? name 'api) (eq? name 'auth') (eq? name 'mobileapp))
        (list
          "\nexport const loadLocal = (pathToConfig: string, overrideGlobalConfig: boolean=true): (envvar: string) => string => {"
          "\n  if (process.env['NODE_ENV'] == undefined) throw new Error('NODE_ENV not set');"
          "\n  const matches = /.*\\/([^\\/].*)\\/([^\\/].*)\\/([^\\/].*)$/.exec(pathToConfig);"
          "\n  if (matches == undefined || matches.length != 4) throw new Error(`invalid config path '${pathToConfig}'`);"
          "\n  // @ts-ignore"
          "\n  const [_0, _1, stage, _2] = matches;"
          "\n  const stg = stage === 'development' ? 'dev' : stage;"
          "\n  const fspath = 'fs';"
          "\n  const fs = require(fspath); // force dynamic loading of fs by using a variable"
          "\n  const data = fs.readFileSync(`${__dirname}/${pathToConfig}`) as Buffer;"
          "\n  const config: Obj<string> = {};"
          "\n  data.toString().trim().split('\\n').map(p => p.split('=')).filter(([k, v]) => k !== '').forEach(([k, v]) => config[k] = v);"
          "\n  config['CFG::Stage'] = stg;"
          "\n  if (overrideGlobalConfig) {"
          "\n    _config = config;"
          "\n    _loaded = true;"
          "\n  }"
          "\n  return (envvar: string) => {"
          "\n    if (config[envvar] == undefined) {"
          "\n      throw new Error(`config error: property '${envvar}' is undefined`);"
          "\n    }"
          "\n    return config[envvar]!;"
          "\n  };"
          "\n}"
          "\n")
        "\n")
      "\nexport const serialize = (): string => JSON.stringify({v: 1, cfg: _config });"
      "\nexport const deserialize = (data: string) => {"
      "\n  const json = JSON.parse(data);"
      "\n  if (json.v == 1) {"
      "\n    _config = json.cfg;"
      "\n  } else {"
      "\n    console.warn('could not deserialized cfg');"
      "\n  }"
      "\n};"
      (if (or (eq? name 'webapp) (eq? name 'mobileapp))
        (list
          "\nconst fetchWithTimeout = async (url: string, timeoutMSecs: number) => {"
          "\n  return new Promise<Response>(async (resolve, reject) => {"
          "\n    let timeout: any = undefined;"
          "\n    timeout = setTimeout(() => {"
          "\n      timeout = undefined;"
          "\n      reject(new Error('Request timed out'));"
          "\n    }, timeoutMSecs);"
          "\n    try {"
          "\n      const response = await fetch(url);"
          "\n      if (timeout != undefined) {"
          "\n        clearTimeout(timeout);"
          "\n        timeout = undefined;"
          "\n        resolve(response);"
          "\n      }"
          "\n    } catch (err) {"
          "\n      if (timeout != undefined) {"
          "\n        clearTimeout(timeout);"
          "\n        timeout = undefined;"
          "\n        reject(err);"
          "\n      }"
          "\n    }"
          "\n  });"
          "\n}") "")
      "\nexport const load = async (name: string): Promise<void> => {"
      "\n  _name = name;"
      "\n"
      "\n  // TODO: figure out a good caching strat"
      "\n  //if (_loaded) throw new Error('load already invoked');"
      "\n"
      (if (eq? name 'webapp) ""
        (if (eq? name 'mobileapp)
          "\n  const AWS = require('aws-sdk/dist/aws-sdk-react-native');\n"
          "\n  const AWS = require('aws-sdk');\n"))
      (if (eq? name 'webapp) ""
        (if (eq? name 'mobileapp)
          (list "\n  const localenv = require('./config.local').default;"
                "\n  if (localenv != undefined) {"
                "\n    Object.keys(localenv || {}).map(k => _config[k] = process.env[k] = localenv[k]);"
                "\n  }")
          (list "\n  if (process.env['NODE_ENV'] === 'local' || process.env['NODE_ENV'] === 'test') {"
                "\n    process.env['AWS_LAMBDA_FUNCTION_NAME'] = process.env['NODE_ENV'];"
                "\n    process.env['AWS_REGION'] = 'us-east-1';"
                "\n  }")))
      (if (not (eq? name 'mobileapp)) ""
        (list
          "\n  const AsyncStorage = require('react-native').AsyncStorage;"
          "\n  const envOverride = await AsyncStorage.getItem('OVERRIDE.NODE_ENV');"
          "\n  const regionOverride = await AsyncStorage.getItem('OVERRIDE.AWS_REGION');"
          "\n  if (!!envOverride && !!regionOverride) {"
          "\n    process.env['NODE_ENV'] = _config['NODE_ENV'] = envOverride;"
          "\n    process.env['AWS_REGION'] = _config['AWS_REGION'] = regionOverride;"
          "\n  }"))
      "\n  if (process.env['AWS_REGION'] == undefined) throw new Error('region not set');"
      "\n"
      (if (eq? name 'webapp) ""
        (list
          "\n  const s3 = new AWS.S3();"
          "\n  const kms = new AWS.KMS({ region: process.env['AWS_REGION'] });"
          "\n"))
      "\n  const lambdaName = process.env['AWS_LAMBDA_FUNCTION_NAME'];"
      "\n  if (lambdaName == undefined) {"
      "\n    if (process.env['NODE_ENV'] == undefined) throw new Error('NODE_ENV not set');"
      "\n    const stage = process.env['NODE_ENV'] === 'development' ? 'dev': process.env['NODE_ENV'] || ''; // workaround for react-native"
      "\n    _stage = stage;"
      "\n    // @ts-ignore"
      "\n    const offlinekey = `CFG:OFFLINE:ENVVARS:[${process.env['AWS_REGION']}]:[${stage}]`;"
      (if (eq? name 'mobileapp)
        "\n    const { Alert } = require('react-native');"
        "")
      "\n    let envvars = '';"
      "\n    while (!envvars) {"
      "\n      try {"
      (if (or (eq? name 'webapp) (eq? name 'mobileapp))
        "\n        const response = await fetchWithTimeout(`https://config-${process.env['AWS_REGION']}.${DOMAIN}/lookup?key=${stage}/${name}`, 5000);"
        "\n        const response = await fetch(`https://config-${process.env['AWS_REGION']}.${DOMAIN}/lookup?key=${stage}/${name}`);")
      "\n        envvars = await response.text();"
      "\n        if (response.status != 200) {"
      "\n          console.error(`bad config response: ${envvars} (${response.status})`);"
      "\n          throw new Error(`bad config response: ${envvars} (${response.status})`);"
      "\n        }"
      "\n      } catch (err) {"
      (if (not (eq? name 'mobileapp)) 
        (list "\n        throw err;")
        (list "\n        envvars = await AsyncStorage.getItem(offlinekey) as string;"))
      "\n      }"
      (if (eq? name 'mobileapp)
        (list
          "\n      if (!envvars) {"
          "\n        await new Promise((resolve, reject) => {"
          "\n          Alert.alert('Oops!', 'Unable to connect to server, please try again later.', [{ text: 'Try Again', onPress: () => resolve() }], { cancelable: false });"
          "\n        });"
          "\n      }")
        "\n      break;")
      "\n    }"
      "\n    if (envvars.charAt(0) === '{') throw new Error(`invalid response from config endpoint ${envvars}`);"
      "\n    envvars.split('\\n').forEach(pair => {"
      "\n      const [key, value] = pair.split('=');"
      "\n      _config[key] = value;"
      "\n    });"
      "\n    _config['CFG::Stage'] = stage;"
      (if (not (eq? name 'mobileapp)) ""
        (list "\n    if (envvars) { await AsyncStorage.setItem(offlinekey, envvars); }"))
      "\n  } else {"
      "\n    let stage = lambdaName;"
      "\n    if (process.env['NODE_ENV'] != 'local' && process.env['NODE_ENV'] != 'test') {"
      "\n      const matches = /-(dev|beta|production)-/.exec(lambdaName);"
      "\n      if (!matches || matches.length != 2) throw new Error(`failed to parse environment, got lambda-name: '${lambdaName}', from env: '${process.env['NODE_ENV']}'`);"
      "\n      stage = matches[1];"
      "\n    }"
      "\n    _stage = stage;"
      "\n"
      (if (eq? name 'webapp) ""
        (list
          (if (eq? name 'api)
            (list
              "\n    const is_ci = process.env['NODE_ENV'] == 'test' && process.env['AWS_ACCESS_KEY_ID'] == undefined && name == 'api';"
              "\n    if (is_ci) {"
              "\n      const fs = require('fs');"
              "\n      const data = fs.readFileSync(`${__dirname}/../../../../infra/config/src/us-east-1/test/api`) as Buffer;"
              "\n      data.toString().trim().split('\\n').map(p => p.split('=')).filter(([k, v]) => k !== '').forEach(([k, v]) =>"
              "\n        _config[k] = v);"
              "\n      _config['CFG::Stage'] = stage;"
              "\n    } else {")
            (list
              "\n    if (true) {"))
          "\n      try {"
          "\n        const result = await s3.getObject({"
          "\n          Bucket: `config-${process.env['AWS_REGION']}.${DOMAIN}`,"
          "\n          Key: `${stage}/${name}`,"
          "\n        }).promise();"
          "\n        if (result.Body == undefined) throw new Error('failed to get s3 object');"
          "\n        const data = { Plaintext: result.Body as string };"
          "\n        const envvars = data.Plaintext.toString().trim();"
          "\n        const envvarsplits = envvars.split('\\n');"
          "\n        for (let i=0; i<envvarsplits.length; ++i) {"
          "\n          const pair = envvarsplits[i];"
          "\n          const [key, value] = pair.split('=');"
          "\n          if (value.indexOf('?:') == 0) {"
          "\n            const split = value.split(':');"
          "\n            if (split.length != 2 || !split[1]) throw new Error('failed to parse secret');"
          "\n            const secret = split[1];"
          "\n            const decryptResult = await kms.decrypt({"
          "\n              CiphertextBlob: Buffer.from(secret, 'base64'),"
          "\n            }).promise();"
          "\n            if (decryptResult.Plaintext == undefined) throw new Error('failed to decrypt');"
          "\n            _config[key] = decryptResult.Plaintext.toString();"
          "\n          } else {"
          "\n            _config[key] = value;"
          "\n          }"
          "\n        }"
          "\n        _config['CFG::Stage'] = stage;"
          "\n      } catch (err) {"
          "\n        if (err.code == 'AccessDenied') {"
          "\n          throw new Error(`ACCESS DENIED - failed to access configuration (name=${_name} stage=${stage} node-env=${process.env['NODE_ENV']} lambda-name=${lambdaName})`);"
          "\n        }"
          "\n        throw err;"
          "\n      }"
          "\n    }"))
      "\n  }"
      "\n  _loaded = true;"
      "\n  if (_handlers != undefined) {"
      "\n    const handlers = _handlers;"
      "\n    for (let hi=0; hi<handlers.length; ++hi) {"
      "\n      await handlers[hi]();"
      "\n    }"
      "\n    _handlers = undefined;"
      "\n  }"
      "\n}"
      "\n"
      "\nexport const hasLoaded = (): boolean => _loaded;"
      "\nexport const onUnload = (() => {"
      "\n  const fns: (() => Promise<void>)[] = [];"
      "\n"
      "\n  let called = false;"
      "\n  const exit = async (exit: any, signal?: any) => {"
      "\n    if (called) return;"
      "\n    called = true;"
      "\n    for (let i=0; i<fns.length; ++i) await fns[i]();"
      "\n    if (exit === true) process.exit(128 + signal);"
      "\n  };"
      "\n"
      "\n  return (fn: () => Promise<void>) => {"
      "\n    fns.push(fn);"
      "\n    if (fn.length === 1) {"
      "\n      process.once('exit', exit);"
      "\n      process.once('SIGINT', exit.bind(null, true, 2));"
      "\n      process.once('SIGTERM', exit.bind(null, true, 15));"
      "\n    }"
      "\n  };"
      "\n})();"))

  (define (configs-generate name)
    (smoosh (config-emit name)))
  )

