(module tools (
               downcase method->description method->params method->defaults-assq method->params-assq param->default
               param->default-or param-default?  make-param param->specs-assq specs->assq model->foreign
               param-primary-key? param->specs param->value model->typedef models-assq model->api
               first-up first-down map-queries map-mutations make-specs typedef-assq typedef-assq!
               method->return-type method->name model->all-methods method->mode get? set?
               model->name model->methods model->type scalar->name typedef->name typedef->params
               inputdef->name inputdef->params api->scalars api->typedefs api->inputdefs api->models
               api->models-assq native-type? optional? make-optional optional->type make-array array?
               array->type model? scalar? typedef? group-by method->version param-disabled?
               indent param->type param->name param->metadata type->name type->fields model->props-assq model->props
               foreign-field->key foreign-field->fkey foreign-field->fmodel foreign-field->selector foreign-field->type
               foreign-field->name param-foreign-field? param->foreign-field typedef->params-assq
               typedef->params+foreign lower upper model->options model-usermodel? method-command? method->command
               method-disabled? model-disabled? typedef->options typedef-disabled? model-serviceonly? model-serviceapionly?
               map-methods map-queries-ex map-mutations-ex method->access method->config method-serviceonly?
               eval-selector-params eval-selector-param eval-foreign-field eval-copied-field eval-param method->config-assq model-typedef? model-assq-typedef?
               method-strict-ownership? method-apionly? method-dbonly? base-type version-name->number number->version-name
               version-name-floor method-ascending? param->copied-field param-copied-field? method-param-rename
               copied-field->key copied-field->fkey copied-field->fmodel copied-field->selector api->indices api->index-destroys param-readonly?
               param-hidden? index->typename index->settings index-unique? model-assq typename->modelname
               make-fieldvalue fieldvalue? fieldvalue-default? fieldvalue->name fieldvalue->value sub-field?
               method+typedef->fieldvalues cursorize paginated-type model->cached-array-methods method-returns-array?
               cached-array-keys cached-array-key select? method->special-props foreign-field+user?
               method->return-props method->implied-sub-field smoosh method-cache-expire? method->cache-expire
               model->unique-index-fieldnames model->props+foreign model->hidden-props command->cmdtype api->type-extensions
               type-extension->typename type-extension->param specs->find plus-type? plus-type->types make-plus-type
               )

  (import scheme chicken data-structures commands matchable)
  (require-extension srfi-13 srfi-1)

  (define (command->cmdtype model method mode)
    (define (mode->cmdtype mode)
      (match mode
             ;('Register 'create)
             ;('UpdateMe 'update)
             ;('Unregister 'delete)
             (_ (error "mode->cmdtype - unknown command type mode " mode))))
    (if (not (method-command? method))
        (mode->cmdtype mode)
        (let ((cmd (cons 'command (method->command method))))
          (match cmd
                 (`(command (update . ,rs) . ,rrs) 'update)
                 (`(command (insert . ,rs) . ,rrs) 'create)
                 (`(command (delete . ,rs) . ,rrs) 'delete)
                 (`(command (select . ,rs) . ,rrs) 'update)
                 (_ (error (smoosh "command->cmdtype - unknown command type " mode " - " (->string cmd))))))))

  (define (version-name->number v) (string->number (list->string (cdr (string->list (symbol->string v))))))
  (define (number->version-name n) (string->symbol (string-append "v" (number->string n))))
  (define (version-name-floor v) (number->version-name (inexact->exact (floor (version-name->number v)))))

  (define (typename->modelname api typename)
    (let ((result (model-assq typename api)))
      (if (not result) (error (string-append "model name '" (symbol->string typename) "' not found"))
        (model->name (cadr result)))))

  (define (base-type x)
    (cond
      ((optional? x) (base-type (optional->type x)))
      ((array? x) (base-type (array->type x)))
      ((plus-type? x) x)
      ((symbol? x) x)
      (else (error "unknown param type!" x))))

  (define (lower x)
    (cond ((string? x) (string-downcase x))
          ((symbol? x) (string->symbol (string-downcase (symbol->string x))))
          (error "unknown 'lower type" x)))

  (define (upper x)
    (cond ((string? x) (string-downcase x))
          ((symbol? x) (string->symbol (string-upcase (symbol->string x))))
          (error "unknown 'upper type" x)))

  (define (group-by keyfn tffn xs)
    (define (replace-if pred new l)
      (map (lambda (i) (if (pred i) new i)) l))
    (define (recur acc l)
      (if (null? l) acc
        (let ((x (car l)))
          (let ((key (keyfn x)))
            (let ((prev (assq key acc)))
              (recur (if (not prev)
                       (append acc (list (list key (list (tffn x)))))
                       (replace-if (lambda (i) (eq? (keyfn i) key))
                                   (list key (append (cadr prev) (list (tffn x)))) acc)) (cdr l)))))))
    (recur '() xs))
 
  (define (downcase x)
    (cond ((symbol? x) (string->symbol (string-downcase (symbol->string x))))
          ((string? x) (string-downcase x))
          (else x)))

  (define (string-transform-first fn str)
    (if (null? str) ""
      (let ((l (string->list str)))
        (list->string (cons (fn (car l)) (cdr l))))))

  (define (first-up s)
    (define (string-up s) (string-transform-first char-upcase s))
    (define (symbol-up s) (string->symbol (string-up (symbol->string s))))
    (cond ((symbol? s) (symbol-up s))
          ((string? s) (string-up s))
          (else s)))
  (define (first-down s)
    (define (string-down s) (string-transform-first char-downcase s))
    (define (symbol-down s) (string->symbol (string-down (symbol->string s))))
    (cond ((symbol? s) (symbol-down s))
          ((string? s) (string-down s))
          (else s)))

  (define (indent n) 
    (define (recur i) (if (zero? i) '() (cons "  " (recur (- i 1)))))
    (apply string-append (recur n)))

  (define (native-type? t) (memq t (list 'String 'Int 'Float 'DateTime 'Boolean 'Point)))

  (define (make-optional x) (list 'Optional x))
  (define (optional? x) (and (pair? x) (eq? (car x) 'Optional)))
  (define optional->type cadr)

  (define (make-array x) (list 'Array x))
  (define (array? x) (and (pair? x) (eq? (car x) 'Array)))
  (define array->type cadr)

  (define (make-method mode version body rest) (cons mode (cons version (cons body rest))))
  (define (method-options-map fn method)
    (let ((params (method->params method)))
      (if (null? params)
        method
        (make-method
          (method->mode method)
          (method->version method)
          (method->body method)
          (cons (cons 'opts (map fn (method->options method))) '())))))
  (define (method->params-assq name method)
    (let ((result (filter (lambda (p) (eq? name (param->name p)))
                          (method->params method))))
      (if (null? result) #f
        (car result))))
  (define (method->defaults-assq name method)
    (let ((result (method->config-assq 'defaults method)))
      (if (not result) #f
        (let ((result (cdar result)))
          (assq name result)))))
  (define (method-params-map fn method)
    (method-options-map (lambda (opt) 
                          (let ((name (car opt)) (value (cdr opt)))
                            (if (eq? name 'params)
                              (cons name (map fn value))
                              opt))) method))
  (define (method-param-rename method old-param-name new-param-name)
    (method-params-map (lambda (param) 
                         (if (eq? (param->name param) old-param-name)
                           (param-rename param new-param-name)
                           param)) method))
  (define (map-methods fn pred? api) 
    (map (lambda (model)
           (map (lambda (method) 
                  (fn method model))
                (filter pred? (model->methods model))))
         (api->models api)))
  (define method->mode car)
  (define method->version cadr)
  (define method->body caddr)
  (define method->rest cdddr)
  (define (method->options method)
    (if (or (null? (method->rest method))
            (not (eq? (caar (method->rest method)) 'opts))
            (not (pair? (cdar (method->rest method))))) '()
      (cdar (method->rest method))))
  (define (get? method) (eq? (method->mode method) 'get))
  (define (set? method) (eq? (method->mode method) 'set))
  (define (method->name method) (car (method->body method)))
  (define (method->description method) (cadr (method->body method)))
  (define (method->return-type method) (caddr (method->body method)))
  (define (method->params method)
    (let ((result (assq 'params (method->options method))))
      (if (not result) '()
        (cdr result))))
  (define (method-disabled? method name)
    (let ((result (assq 'disable (method->options method))))
      (if (not result) #f (not (not (member name (cadr result)))))))
  (define (method->access method)
    (let ((result (assq 'access (method->options method))))
      (if (not result) #f (cadr result))))
  (define (method->config method)
    (let ((result (assq 'config (method->options method))))
      (if (not result) #f (cdr result))))
  (define (method->config-assq name method)
    (let ((config (method->config method)))
      (if (not config) #f
        (let ((result (assq name config)))
          (if (or (not result) (null? result)) #f (cdr result))))))
  (define (method-dbonly? method)
    (let ((result (assq 'db-only? (method->options method))))
      (if (not result) #f (cadr result))))
  (define (method-apionly? method)
    (let ((result (assq 'api-only? (method->options method))))
      (if (not result) #f (cadr result))))
  (define (method-serviceonly? method)
    (let ((result (assq 'service-only? (method->options method))))
      (if (not result) #f (cadr result))))
  (define (method-strict-ownership? model method)
    (let ((implicit-paramnames (if (not (model-typedef? model)) #f (method->config-assq 'implicit method))))
      (if (not implicit-paramnames) #f
        (member 'sub implicit-paramnames))))
  (define (method-ascending? method)
    (let ((orderby (method->config-assq 'orderby method)))
      (if (not orderby) #t
        (not (member 'descending orderby)))))
  (define (method-cache-expire? method)
    (let ((result (method->config-assq 'cache-expire method)))
      (if (not result) #f #t)))
  (define (method->cache-expire method)
    (let ((result (method->config-assq 'cache-expire method)))
      (if (not result) (error "method does not have a cache-expire")
        result)))
  (define (method-command? method)
    (let ((cmd (method->config-assq 'command method)))
      (if (not cmd) #f #t)))
  (define (method->command method)
    (let ((cmd (method->config-assq 'command method)))
      (if (not cmd) (error "method does not have a command")
        cmd)))
  (define (method-cache-keys? method)
    (let ((cmd (method->config-assq 'cache-key method)))
      (if (not cmd) #f #t)))
  (define (method->cache-keys method)
    (let ((ckey (method->config-assq 'cache-key method)))
      (if (not ckey) (error "method does not have a cachekey")
        ckey)))
  (define (method->special-props model method)
    (let ((props (model->props model)))
      (if (method-command? method)
        (let ((specials (command->filter command-special? (method->command method))))
          (remove not (map (lambda (name) (assq name props)) specials)))
        '())))
  (define (method->implied-sub-field model method)
    (let ((field (assq 'sub (method->special-props model method))))
      (if (not field) '() field)))
  (define (method->returns method)
    (if (method-command? method)
      (command->returns (method->command method))
      '()))
  (define (method->return-props model method)
    (let ((props (model->props+foreign model)))
      (if (method-command? method)
        (remove not (map (lambda (name) (assq name props))
                         (command->returns (method->command method))))
        '())))

  ; type-extend
  (define (type-extension? x) (and (pair? x) (eq? (car x) 'type-extend)))
  (define type-extension->typename cadr)
  (define (type-extension->param ext)
    (let ((param (caddr ext)))
      (if (not (param-default? param))
        (error (apply string-append (list "type extension '" (->string (param->name param)) " requires a default value")))
        param)))

  ; index
  (define (index? x) (and (pair? x) (eq? (car x) 'index)))
  (define (index-destroy? x) (and (pair? x) (eq? (car x) 'index-destroy)))
  (define index->typename cadr)
  (define index->settings caddr)
  (define (index->options index) (cdr (cadddr index)))
  (define (index-unique? index)
    (let ((result (assq 'unique (index->options index))))
      (if (not result) #f
        (cadr result))))

  ; scalar
  (define (scalar? x) (and (pair? x) (eq? (car x) 'scalar)))
  (define scalar->name cadr)

  ; typedef
  (define (typedef? x) (and (pair? x) (eq? (car x) 'type)))
  (define (typedef->options typedef)
    (if (null? (cddr typedef)) '()
      (let ((result (assq 'opts (cddr typedef))))
        (if (not result) '()
          (cdr result)))))
  (define (typedef-disabled? typedef name)
    (let ((result (assq 'disable (typedef->options typedef))))
      (if (not result) #f (not (not (member name (cadr result)))))))
  (define typedef->name caadr)
  (define typedef->params cdadr)
  (define (typedef-assq name api) 
    (let ((ret (assq name (map (lambda (typedef) (list (typedef->name typedef) typedef)) (api->typedefs api)))))
      (if (not ret) #f (cadr ret))))
  (define (typedef-assq! name api) 
    (let ((ret (typedef-assq name api)))
      (if (not ret) (error "failed to find typedef named " name)
        ret)))
  (define (typedef->params-assq typedef param-name)
    (let ((params (typedef->params typedef)))
      (assq param-name (map (lambda (p) (list (param->name p) p)) params))))
  (define (typedef->foreign entire-api api typedef)
    (define (lookup-model-prop-type api model-name prop-name)
      (let ((result (api->models-assq api model-name)))
        (if (not result) (list '() '())
          (let ((model (cadr result)))
            (let ((result2 (model->props-assq model prop-name)))
              (if (not result2) (list '() '())
                (let ((param (cadr result2)))
                  (list (param->type param) (param->specs param)))))))))
    (remove
      null?
      (map (lambda (param)
             (let ((ff (param->foreign-field param)))
               (let* ((prop-type+specs (lookup-model-prop-type api (foreign-field->fmodel entire-api ff) (foreign-field->fkey ff)))
                      (prop-type (car prop-type+specs))
                      (specs (cadr prop-type+specs)))
                 (if (eq? (foreign-field->fkey ff) 'sub) '()
                   (if (null? prop-type) (error "foreign-field does not exist")
                     ff)))))
           (filter param-foreign-field? (typedef->params typedef)))))
  (define (typedef->params+foreign entire-api api typedef)
    (define (lookup-model-prop-type api model-name prop-name)
      (let ((result (api->models-assq api model-name)))
        (if (not result) (list '() '())
          (let ((model (cadr result)))
            (let ((result2 (model->props-assq model prop-name)))
              (if (not result2) (list '() '())
                (let ((param (cadr result2)))
                  (list (param->type param) (param->specs param)))))))))
    (remove
      null?
      (map (lambda (param)
             (if (not (param-foreign-field? param))
               param
               (let ((ff (param->foreign-field param)))
                 (let* ((prop-type+specs (lookup-model-prop-type api (foreign-field->fmodel entire-api ff) (foreign-field->fkey ff)))
                        (prop-type (car prop-type+specs))
                        (specs (cadr prop-type+specs)))
                   (if (eq? (foreign-field->fkey ff) 'sub) '()
                     (if (null? prop-type) (error "foreign-field does not exist")
                       (make-param (foreign-field->key ff) prop-type
                                   (if (specs->assq 'force-numeric specs)
                                     '(specs (force-numeric #t)) '(specs)))))))))
           (typedef->params typedef))))

  (define (foreign-field+user? field)
    (and (param-foreign-field? field)
         (eq? (param->name field) 'user)))

  ; inputdef
  (define (make-inputdef name params) (list 'input (cons name params)))
  (define (inputdef? api x)
    (and (typedef? x)
         (let ((mtypes (map model->type (api->models api))))
           (member (typedef->name x) mtypes))))
  (define inputdef->name caadr)
  (define inputdef->params cdadr)

  ; model
  (define m-wrap cons)
  (define m-unwrap cdr)
  (define model->api car)
  (define (model? x) (and (pair? x) (pair? (m-unwrap x)) (eq? (car (m-unwrap x)) 'model)))
  (define (model->name model) (caadr (m-unwrap model)))
  (define (model->all-methods model) (cdr (assq 'methods (cdadr (m-unwrap model)))))
  (define (model->methods model) (cdr (assq 'methods (cdadr (m-unwrap model)))))
  (define (model-assq typename api)
    (let ((result (assq typename (map (lambda (m) (list (model->type m) m)) (api->models api)))))
      result))
  (define (model->type model)
    (let ((result (assq 'type (cdadr (m-unwrap model)))))
      (if (not result) #f (cadr result))))
  (define (model->options model) 
    (let ((result (assq 'opts (cdadr (m-unwrap model)))))
      (if (not result) '()
        (cdr result))))
  (define (model-disabled? model name)
    (let ((result (assq 'disable (model->options model))))
      (if (not result) #f (not (not (member name (cadr result)))))))
  (define (model-serviceapionly? model)
    (let ((result (assq 'serviceapi-only? (model->options model))))
      (if (not result) #f (cadr result))))
  (define (model-serviceonly? model)
    (let ((result (assq 'service-only? (model->options model))))
      (if (not result) #f (cadr result))))
  (define (model-usermodel? model)
    (let ((result (assq 'user (model->options model))))
      (if (not result) #f
        (cadr result))))
  (define (model-typedef? model) (not (not (model->type model))))
  (define (model-assq-typedef? model)
    (let ((typedef (typedef-assq (model->type model) (model->api model))))
      (not (not typedef))))
  (define (model->typedef model) 
    (let ((typedef (typedef-assq (model->type model) (model->api model))))
      (if (not typedef)
        (error (apply string-append (map ->string (list "typedef-assq failed - " (model->type model) " not found"))))
        typedef)))
	(define (models-assq name api) (m-wrap api (list 'model (assq name (map cadr (map m-unwrap (api->models api)))))))
  (define (model->props-assq model prop-name)
    (let ((typedef (model->typedef model)))
      (typedef->params-assq typedef prop-name)))
  (define (model->props model)
    (let ((typedef (model->typedef model)))
      (typedef->params typedef)))
  (define (model->props+foreign model)
    (let ((typedef (model->typedef model)))
      (typedef->params+foreign (model->api model) (model->api model) typedef)))
  (define (model->cached-array-methods model)
    (filter (lambda (m) 
              (and (not (method-disabled? m 'rdsstore))
                   (get? m)
                   (method-returns-array? m)))
            (model->methods model)))
  (define (model->unique-index-fieldnames model)
    (let ((typedef-name (typedef->name (model->typedef model))))
      (append
        (map (lambda (p) (param->name p))
             (filter (lambda (p) (param->specs-assq 'unique p))
                     (model->props model)))
        (apply append (map (lambda (idx) (car (index->settings idx)))
             (filter (lambda (idx) (and (index-unique? idx) (eq? typedef-name (index->typename idx))))
                     (api->indices (model->api model))))))))
  (define (model->hidden-props model)
    (let ((props (model->props+foreign model)))
      (remove (compose not param-hidden?) props)))
  (define (model->foreign model)
    (if (not (model-typedef? model)) (list)
      (typedef->foreign (model->api model) (model->api model) (model->typedef model))))

  ; api
  (define (api->scalars api) (filter scalar? api))
  (define (api->typedefs api) (filter typedef? api))
  (define (api->models api) (filter model? (map (lambda (m) (m-wrap api m)) api)))
  (define (api->indices api) (filter index? api))
  (define (api->index-destroys api) (filter index-destroy? api))
  (define (api->type-extensions api) (filter type-extension? api))
  (define (api->models-assq api model-name)
    (let ((asslst (map (lambda (model) (list (model->name model) model)) (api->models api))))
      (assq model-name asslst)))
  (define (typedef->inputdef typedef) 
    (let ((type->input (lambda (s) (string->symbol (string-append (symbol->string s) "Input")))))
      (make-inputdef (type->input (typedef->name typedef)) (typedef->params typedef))))
  (define (api->inputdefs api)
    (map typedef->inputdef
         (remove (lambda (t)
                   (inputdef? api t))
                 (api->typedefs api))))

  ; types (aliases for typedef and inputdef)
  (define type->name typedef->name)
  (define type->fields typedef->params)

  ; param
  (define (make-param . rest) 
    (cond 
      ((= (length rest) 2) (list (car rest) (cadr rest) (make-specs)))
      ((= (length rest) 3) (list (car rest) (cadr rest) (caddr rest)))
      (else (error 'failed-to-make-param))))
  (define param->type cadr)
  (define param->name car)
  (define param->value cadr)
  (define (param->specs param) (if (null? (cddr param)) '(spec) (caddr param)))
  (define (param->specs-assq name param)
    (let ((spec (param->specs param)))
      (if (null? spec) #f
        (specs->assq name spec))))
  (define (param->specs-find name param)
    (let ((spec (param->specs param)))
      (if (null? spec) #f
        (specs->find name spec))))
  (define (param-primary-key? param) (param->specs-assq 'primary-key param))
  (define (param-default? param) (not (not (param->specs-find 'default param))))
  (define (param->default param) (param->specs-assq 'default param))
  (define (param->default-or param or-value)
    (let ((result (param->specs-find 'default param)))
      (if (not result) or-value (cadr result))))
  (define (param-readonly? param) (param->specs-assq 'readonly param))
  (define (param-hidden? param) (param->specs-assq 'hidden param))
  (define (param-disabled? param name)
    (let ((result (param->specs-assq 'disable param)))
      (if (not result) #f (not (not (member name result))))))
  (define (param->metadata param name)
    (let ((result (param->specs-assq 'metadata param)))
      (if (not result) #f
        (let ((result2 (assq name result)))
          (if (not result2) #f
            (cdr result2))))))
  (define (param->foreign-field param) (param->metadata param 'foreign-field))
  (define (param-foreign-field? param) (not (not (param->foreign-field param))))
  (define (param->copied-field param) (param->metadata param 'copied-field))
  (define (param-copied-field? param) (not (not (param->copied-field param))))
  (define (param-rename param new-name) (make-param new-name (param->type param) (param->specs param)))

  ; specs
  (define (make-specs . rest) (cons 'spec rest))
  (define (specs->assq name spec) 
    (let ((result (assq name (cdr spec))))
      (if result (cadr result) #f)))
  (define (specs->find name spec) (assq name (cdr spec)))

  ; query
  (define (map-queries fn api) (map-methods fn get? api))
  (define (map-queries-ex disable-tag fn api)
    (map-methods fn (lambda (m) (and (not (method-disabled? m disable-tag)) (get? m))) api))

  ; mutation
  (define (map-mutations fn api) (map-methods fn set? api))
  (define (map-mutations-ex disable-tag fn api)
    (map-methods fn (lambda (m) (and (not (method-disabled? m disable-tag)) (set? m))) api))

  ; foreign-field
  (define foreign-field->key car)
  (define foreign-field->fkey cadr)
  (define foreign-field->name caddr)
  (define foreign-field->type cadddr)
  (define (foreign-field->selector ff) (cadr (cdddr ff)))
  (define (foreign-field->fmodel api ff) (typename->modelname api (foreign-field->type ff)))

  ; selector
  (define (eval-selector-params api selector type)
    (let ((typedef (typedef-assq type api)))
      (if (not typedef) (error "unknown selector param type" type)
        (let ((params (remove param-hidden? (typedef->params typedef))))
          (cond
            ((null? selector) params)
            ((symbol? selector)
             (let ((result (assq selector params)))
               (if (not result) (error (string-append "invalid selector value (1) " (->string selector)))
                 (eval-selector-params api '() (param->type result)))))
            (else (error "invalid selector syntax " selector)))))))

  (define (eval-selector-param api selector param)
    (cond
      ((null? selector) param)
      ((symbol? selector)
       (let ((params (typedef->params (typedef-assq (param->type param) api))))
         (let ((result (assq selector params)))
           (if (not result) (error (string-append "invalid selector value (2) " (->string selector) " - " (->string params)))
             (let ((ret-param (make-param
                                (param->name param)
                                (param->type result)
                                (param->specs result))))
               ;(print ":::" ret-param)
               (eval-selector-param api '() ret-param))))))
      ;((list? selector)
       ;(print selector)
       ;(let ((innerParams (typedef->params (typedef-assq (param->type param) api))))
         ;(filter (lambda (innerParam)
                   ;(find-tail (lambda (name) (eq? (param->name innerParam) name)) selector))
                 ;innerParams)))
                 ;))
      (else (error "invalid selector syntax " selector))))

  (define (eval-param api param)
    (if (param-foreign-field? param)
      (let* ((ff (param->metadata param 'foreign-field))
             (fftype (foreign-field->type ff)))
        (let ((ret-param (eval-selector-param
                           api (foreign-field->selector ff)
                           (make-param (foreign-field->name ff) fftype))))
          (make-param
            (param->name ret-param)
            (let ((ret-type (param->type ret-param)))
              (if (optional? ret-type) ret-type (make-optional ret-type)))
            (param->specs ret-param))))
      param))

  (define (eval-foreign-field type api param)
    (if (param-foreign-field? param)
      (let* ((ff (param->metadata param 'foreign-field)))
        (assq (foreign-field->key ff) (typedef->params+foreign api api type)))
      param))

  (define copied-field->key car)
  (define copied-field->fkey cadr)
  (define copied-field->fmodel caddr)
  (define copied-field->selector cadddr);

  (define (eval-copied-field type api param)
    (if (param-copied-field? param)
      (let* ((cf (param->metadata param 'copied-field))
             (selector (copied-field->selector cf)))
        (let ((ret-param (eval-selector-param api selector param)))
          (make-param
            (param->name ret-param)
            (let ((ret-type (param->type ret-param)))
              (if (optional? ret-type) ret-type (make-optional ret-type)))
            ;(param->type ret-param)
            (param->specs ret-param))))
      param))

  ; fieldvalue
  (define (make-fieldvalue default? name value) (list 'fieldvalue default? name value))
  (define (fieldvalue? value) (and (pair? value) (eq? (car value) 'fieldvalue)))
  (define fieldvalue-default? cadr)
  (define fieldvalue->name caddr)
  (define fieldvalue->value cadddr)
  (define (method+typedef->fieldvalues method typedef)
    (let ((readonly-fields (filter param-readonly? (typedef->params typedef))))
      (map (lambda (field)
             (let ((method-default-param (method->defaults-assq (param->name field) method)))
               (cond
                 ((not (not method-default-param))
                  (make-fieldvalue #t (param->name method-default-param) (param->type method-default-param)))
                 ((param-default? field)
                  (make-fieldvalue #t (param->name field) (param->default-or field "")))
                 (else 
                   (make-fieldvalue #f (param->name field) (param->type field))))))
           readonly-fields)))

  (define (cursorize emit-fn type)
    (if (array? type)
      (let ((child-type (array->type type)))
        (if (native-type? child-type)
          (list "Cursored<" (emit-fn child-type) ">[]")
          (list "(" (emit-fn child-type) " & Cursorize)[]")))
      (list (emit-fn type))))

  (define (paginated-type emit-fn type)
    (if (array? type)
      (let ((ty (array->type type)))
        (if (plus-type? ty)
          (list "Paginated<" (intersperse (map emit-fn (plus-type->types ty)) " & ") ">")
          (list "Paginated<" (emit-fn ty) ">")))
      (list (emit-fn type))))

  (define (method-returns-array? method)
    (let ((ret-type (method->return-type method)))
      (array? ret-type)))

  ; cache
  (define (expand-key method key)
    (let ((type (base-type (param->type (method->params-assq key method)))))
      (match type
             ('Point (list "`${Math.round(" key ".lat*100)/100}:${Math.round(" key ".lon*100)/100}`"))
             (x key))))
  (define (unique-cache-per-sub? model method)
    (if (not (get? method)) #f
      (let ((ssub (command->filter command-special-sub? (method->command method)))
            (asub (command->filter command-arg-sub? (method->command method))))
        (or (not (null? ssub)) (not (null? asub))))))
  (define (cached-array-key model method)
    (let ((keys (if (method-cache-keys? method) (method->cache-keys method) '())))
      (list
        (if (unique-cache-per-sub? model method)
          (list (model->name model) "." (first-down (method->name method)) (list "[${$ctx.sub}]"))
          (list (model->name model) "." (first-down (method->name method))))
        (map (lambda (k) (list "${" k " == undefined ? '' : `[${" (expand-key method k) "}]`}")) keys))))
  (define (cached-array-keys model)
    (map (lambda (method)
           (if (unique-cache-per-sub? model method)
             (list (model->name model) "." (first-down (method->name method)) (list "[${ret.sub}]"))
             (list (model->name model) "." (first-down (method->name method)))))
         (model->cached-array-methods model)))
  (define (sub-field? model method)
    (or (not (null? (method->implied-sub-field model method)))
        (method->params-assq 'sub method)
        (method-strict-ownership? model method)))

  (define (select? cmd)
    (and (pair? cmd) (eq? (car cmd) 'command) (assq 'select (cdr cmd))))

  (define (map-double-up fn l)
    (let ((ret (foldr (lambda (i s)
                        (if (null? (car s)) (cons i (cdr s))
                            (cons '() (cons (fn (list i (car s))) (cdr s)))))
                      (cons '() '()) l)))
      (if (null? (car ret)) (cdr ret)
          (cons (fn (list (car ret))) (cdr ret)))))

  (define (string-append-ex strs)
    (cond
      ((null? strs) "")
      ((null? (cdr strs)) (car strs))
      (else (string-append-ex (map-double-up (lambda (d) (apply string-append d)) strs)))))

  ;(define (smoosh . p) (apply string-append (map ->string (flatten p))))
  (define (smoosh . p) (string-append-ex (map ->string (flatten p))))

  (define (make-plus-type types) (cons '+ types))
  (define (plus-type? type)
    (and (pair? type) (eq? (car type) '+)))
  (define (plus-type->types type)
    (cdr type))
)
