#!/usr/bin/env node
// @ts-check

const fs = require('fs');
const colors = require('colors/safe');
const path = require('path');
const { spawn } = require('child_process');
const { fromEntries, entries } = require('@inf/common');
const { vartools, substituteVariables } = require('./lib/src/vartools');
const V = require('./vars');

const [_1, cmd, ...args] = process.argv;

const printcommands = msg => {
  if (msg) console.log(colors.red(`${msg}\n`));
  console.log(`usage: ${path.basename(cmd)} <command> <subcommand> [...<args>]`);
  console.log('');
  if (fs.existsSync(`${__dirname}/.scripts`)) {
    console.log('available commands:');
    console.log('    COMMANDS');
    fs.readdirSync(`${__dirname}/.scripts`).sort((a, b) => a.localeCompare(b)).forEach(p => {
      const path = p.replace(/(.*)\.json$/, '$1');
      console.log(`    ${colors.grey('-')} ${colors.bold(path)}`);
    });
  }
}

const printrules = (command, rules, msg) => {
  if (msg) console.log(colors.red(`${msg}\n`));
  console.log(`usage: ${path.basename(cmd)} ${command} <subcommand> [...<args>]`);
  console.log('');
  console.log(`available rules for '${command}':`);
  console.log('    RULES                               DESCRIPTION');
  Object.entries(rules).sort((a, b) => a[0].localeCompare(b[0])).forEach(([k, cmd]) => {
    if (cmd.desc) {
      console.log(`    ${colors.grey('-')} ${colors.bold(k.substr(0, 30).padEnd(30, ' '))}    ${colors.grey(cmd.desc || '')}`);
    }
  });
}

if (process.argv.length <= 2) {
  printcommands();
  process.exit(0);
}

if (args.length == 0) {
  printcommands();
  process.exit(0);
}

const [command, ...subargs] = args;
if (!fs.existsSync(`${__dirname}/.scripts/${command}.json`)) {
  printcommands(`command '${command}' not found`);
  process.exit(0);
}

let json = undefined;
try {
  json = JSON.parse(fs.readFileSync(`${__dirname}/.scripts/${command}.json`, { encoding: 'utf8' }));
} catch (err) { }

if (!json) {
  console.error('invalid script', json);
  process.exit(1);
}

const { env, cwd, rules } = json;

if (subargs.length == 0) {
  printrules(command, rules);
  process.exit(0);
}

const [rulename] = subargs;

const rule = rules[rulename];
if (!rule) {
  printrules(command, rules, `rule '${rulename}' not found`);
  process.exit(0);
}

const prepareVariables = scriptenv => {
  const missingVars = [];
  const ret = fromEntries(entries(scriptenv).map(([k, s]) => {
    // @ts-ignore
    const str = substituteVariables({ ...V._vars, ...process.env })(`${s}`);
    if (str == undefined) missingVars.push(k);
    return [k, str];
  }));
  if (missingVars.length > 0)
    throw new Error(`envvars [${missingVars.join(', ')}] must be defined`);
  return ret;
}

const invokeRule = (stdio, cwd, scriptenv, { command, args }, moreargs) => new Promise((resolve, reject) => {
  const fullargs = [...(args || []), ...(moreargs || [])];
  console.log(colors.grey(`${colors.blue('script:')} ${command} ${fullargs.join(' ')} # (CWD: ${cwd})`));
  const env = {
    // @ts-ignore
    ...V._vars,
    ...process.env,
    ...prepareVariables(scriptenv),
    FORCE_COLOR: 'true'
  };
  const convertedargs = fullargs.map(vartools.convertToShell);
  if (stdio == 'inherit') {
    const proc = spawn(command, convertedargs, { shell: true, cwd, env, stdio });
    proc.on('close', code => {
      console.log('');
      if (code == 0) resolve();
      else reject(new Error(`failed to invoke make rule '${rulename}'`));
    });
  } else {
    const proc = spawn(command, convertedargs, { shell: true, cwd, env, stdio });
    proc.stdout.on('data', data => process.stdout.write(colors.grey(data.toString())));
    proc.stderr.on('data', data => process.stderr.write(colors.red(data.toString())));
    proc.on('close', code => {
      console.log('');
      if (code == 0) resolve();
      else reject(new Error(`failed to invoke make rule '${rulename}'`));
    });
    proc.stdin.end();
  }
})

const run = async (stdio, cwd, env, commands) => {
  if (commands.length == 0) return;
  const [fst, ...rst] = commands;
  if (!fst.command) return;
  await invokeRule(stdio, cwd, env || {}, fst, []);
  await run(stdio, cwd, env, rst);
}

run(rule.stdio, rule.cwd || cwd, { ...(env || {}), ...(rule.env || {}) }, rule.commands).catch(err => {
  console.error(colors.red(err));
});
