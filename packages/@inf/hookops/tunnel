#!/usr/bin/env node
// @ts-check

const { spawn } = require('child_process');
const path = require('path');
const colors = require('colors/safe');

const argv = process.argv;

const printUsageAndExit = () => {
  console.log(`usage: ${path.basename(argv[1])} <local-port> <remote-host> <remote-port> <jump-host> ...<args>`);
  process.exit(1);
}

const parseArgs = () => {
  if (argv.length < 7) {
    printUsageAndExit();
  };
  const [_1, _2, localPort, remoteHost, remotePort, jumpHost, ...args] = process.argv;
  return {
    localPort,
    remoteHost,
    remotePort,
    jumpHost,
    args
  };
}

const spawnHelperRaw = async (cmd, args, params) => {
  const sshproc = spawn(cmd, args, { shell: true, stdio: 'inherit' });
  if (params.onClose) sshproc.on('close', code => params.onClose(code));
  return sshproc;
};

const spawnHelper = async (cmd, args, params) => {
  const sshproc = spawn(cmd, args, { shell: true, env: params.env ? { ...params.env, FORCE_COLOR: 'true' } : { ...process.env, FORCE_COLOR: 'true' } });
  if (params.onStdOut) sshproc.stdout.on('data', data => params.onStdErr(data.toString()))
  if (params.onStdErr) sshproc.stderr.on('data', data => params.onStdErr(data.toString()))
  if (params.onClose) sshproc.on('close', code => params.onClose(code));
  sshproc.stdin.end();
  return sshproc;
};

const spawnTunnel = async (localPort, remoteHost, remotePort, jumpHost) => new Promise((resolve, reject) => {
  let ready = false;
  const args = ['-N', '-v', '-L', `${localPort}:${remoteHost}:${remotePort}`, jumpHost];
  const p = spawnHelper('ssh', args, {
    onClose: code => code != 0 && reject(new Error(`process exited with ${code}`)),
    onStdErr: data => {
      if (data.toString().match(/Local forwarding listening on [^ ]+ port [^ ]+./)) {
        if (!ready) {
          ready = true;
          resolve(p);
        }
      }
    },
  });
});

const spawnCommand = async (cmd, args) => new Promise((resolve, reject) => {
  const p = spawnHelperRaw(cmd, args, {
    onClose: code => {
      if (code == 0) resolve(p)
      else reject(new Error(`process exited with ${code}`));
    },
  });
});

const main = async params => {
  console.log(`${colors.blue('tunnel:')} localhost:${params.localPort} -> ${params.remoteHost}:${params.remotePort}`);
  const p = await spawnTunnel(params.localPort, params.remoteHost, params.remotePort, params.jumpHost);
  const [cmd, ...args] = params.args;
  try {
    await spawnCommand(cmd, args);
  } finally {
    p.kill('SIGKILL');
  }
  process.exit(0);
};

main(parseArgs()).catch(err => {
  console.error(err);
  process.exit(1);
});